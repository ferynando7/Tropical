module Polynomial.GraphGen where

import Data.List
import Data.Maybe
import Data.Int
import Debug.Trace
import Data.Map.Lazy (findMin, fromList, filterWithKey, empty, Map, fromListWith)

data Graph a = Graph{nodes::[Position a], edges::[Edge a], raysG::Map (Position a) [Ray a]} deriving (Show)
data Node a = Node{pos::[a], rays::[Ray a]} deriving (Eq)
type Ray a = [a] 
type Edge a = ([a], [a])
type Position a = [a]


instance (Show a, Num a) => Show (Node a) where
    show n = printNode n


printNode :: (Num a, Show a) => Node a -> String
printNode (Node pos rays) = "Pos: " ++ show pos ++ "\n\nRays: " ++ show rays ++ "\n"


inEdges :: (Num a, Eq a) => Edge a -> [Edge a] -> Bool
inEdges ed [e] = eqEdge ed e  
inEdges ed (e:eds)
    | eqEdge ed e = inEdges ed eds
    | otherwise = False

edgInNode ::(Num a, Eq a) => Node a -> [Edge a] -> [Edge a]
-- Give all the edges that has as end the given Node.
edgInNode n@(Node pos _) edges = feasibleEd
    where
        feasibleEd = filter (\x -> (snd x)==pos) edges

fromNode ::(Num a) => Node a -> (Position a, [Ray a])
fromNode (Node pos rays) = (pos, rays)

getPos ::(Num a) => Node a -> Position a
getPos n@(Node pos _) = pos

eqEdge ::(Num a, Eq a) => Edge a -> Edge a -> Bool
eqEdge ed1@((ine1, oue1)) ed2@((ine2, oue2)) = (ine1 == ine2 && oue1 == oue2) || (ine1 == oue2 && oue1 == ine2)

toNode ::(Num a) => Position a -> [Ray a] -> Node a
toNode pos rays = Node pos rays


createGraph ::(Num a, Fractional a, Ord a) => [Node a] -> Graph a
createGraph nodes = Graph nodPos edges rays
    where
        nodPos = map getPos nodes
        preG = preGraph nodes [] [] [] 
        rays = ( joinMap . snd) preG
        edges = fst preG

joinMap ::(Num a, Eq a, Ord a ) => [(Position a, Ray a)] -> Map (Position a) [Ray a]
joinMap mapEl = join
    where 
        keysMap = map (fst) mapEl
        join = (fromList . map (\k -> (k,  map (snd) $ filter (\(pos, ray) -> pos==k ) mapEl )  )) keysMap


preGraph :: (Num a, Eq a, Fractional a, Ord a ) => [Node a] -> [Node a] -> [Edge a] -> [(Position a, Ray a)] -> ([Edge a], [(Position a, Ray a)])
preGraph nodes [] [] [] = preGraph nodes nodes [] []
preGraph [n] _ edges rays = (edges, rays)
preGraph (n@(Node pos rays):nds) ns oldEdges oldRays = preGraph nds ns (oldEdges++newEdges) (oldRays++newRays)
    where
        nodes = ns \\ [n]
        edges = edgInNode n oldEdges
        nConfRays = filter (\x -> isNotConf x edges ) rays
        rayNodes = map (\x -> (x, nodeInRay x pos nodes)) nConfRays
        posEdges = filter (\pos -> (snd pos)/=Nothing) rayNodes
        newRays = map (\x -> (pos, fst x)) (rayNodes \\ posEdges)
        newEdges = map (\pe -> (pos, (fromJust . snd) pe))  posEdges


isNotConf :: (Num a, Eq a, Fractional a) => Ray a -> [Edge a] -> Bool
isNotConf ray [] = True
isNotConf ray [ed] = not(confRayToEdge ray ed)
isNotConf ray (ed:edges)
    | not (confRayToEdge ray ed) = isNotConf ray edges
    | otherwise = False

confRayToEdge :: (Num a, Eq a, Fractional a) => Ray a -> Edge a -> Bool
confRayToEdge ray (ini,end) = if sameLamb == Nothing && nullSame then True else False
    where
        edge = zipWith (-) end ini
        nullRay = filter (==0) ray
        nullEdge = filter (==0) edge
        idxNRay = findIndices (==0) ray
        idxNEdg = findIndices (==0) edge
        comRay = ray\\nullRay
        comEdge = edge\\nullEdge
        zipRE = zipWith (/) comRay comEdge
        lamb = head zipRE
        sameLamb = find (/=lamb) (tail zipRE)
        nullSame = idxNRay == idxNEdg


nodeInRay :: (Num a, Eq a, Fractional a, Ord a) => Ray a -> Position a -> [Node a] -> Maybe (Position a)
-- Give the position of the Node that is on a given Ray and have minimum distance.
nodeInRay ray pos nds = minNode
        where
            --possibles = possibleRays nds ray pos [([], Nothing)]
            possibles = (filterWithKey (\k _ -> k > 0) . fromList . map (\nd -> if oppRay ray nd then ((fromMaybe (-1) $ solveEq ray pos nd),(getPos nd)) else ((-1), []) ) ) nds
            minNode = if possibles == empty then Nothing else Just ((snd . findMin) possibles)
        

oppRay :: (Num a, Eq a) => Ray a -> Node a -> Bool
-- Check if the Ray with opposite direction is in the rays of a Node.
oppRay ray n2@(Node _ raysN2) = opray `elem` listRays
    where
        opray = (map ((-1)*) ray)
        listRays = raysN2


solveEq :: (Num a, Eq a, Ord a, Fractional a) => Ray a -> Position a -> Node a -> Maybe a
-- Given a Ray a Position and a Node, solve the equations generated by the Pos + lamb*Ray = NodePos 
solveEq ray pos n2@(Node p2 _ ) = if check then Just lamb else Nothing
        where
            idxs = findIndices (/=0) ray
            fidx = head idxs
            lamb = (p2!!fidx - pos!!fidx) / (ray!!fidx)
            check
                | lamb >= 0 =  checkSol lamb ray pos p2
                | otherwise = False


checkSol :: (Num a, Eq a) => a -> [a] -> [a] -> [a] -> Bool
checkSol lamb [r] [p] [p2] = p + lamb*r == p2
checkSol lamb (r:rs) (p:pos) (p2:pos2)
    | p + lamb*r == p2 = checkSol lamb rs pos pos2
    | otherwise = False

rx = [1.0,0.0]
ry = [0.0,1.0]
rxy = [1.0,1.0]
rxo = [-1.0,0.0]
ryo = [0.0,-1.0]
rxyo =  [-1.0,-1.0]

n1 = Node {pos=[1.0,1.0], rays=[rx,ry,rxyo]}
n2 = Node {pos=[0.0,0.0], rays=[rxo,ryo,rxy]}
n3 = Node {pos=[-1.0,0.0], rays=[rx,ry,rxyo]}
n4 = Node {pos=[-2.0,-1.0], rays=[rxo,ryo,rxy]}
n5 = Node {pos=[-2.0,-2.0], rays=[rx,ry,rxyo]}
n6 = Node {pos=[-1.0,-2.0], rays=[rxo,ryo,rxy]}
n7 = Node {pos=[0.0,-1.0], rays=[rx,ry,rxyo]}


-- possibleRays :: [Node] -> Ray -> Position -> [(Position, Maybe Float)] -> [(Position, Maybe Float)]
-- possibleRays [] ray pos acc = acc
-- possibleRays [a] ray pos [([], Nothing)] = [(getPos a, solveEq ray pos a)]
-- possibleRays [a] ray pos acc = acc++[(getPos a, solveEq ray pos a)]
-- possibleRays (n:nds) ray pos [([], Nothing)] = [(getPos n, solveEq ray pos n)]++(possibleRays nds ray pos [(getPos n, solveEq ray pos n)] )
-- possibleRays (n:nds) ray pos acc = newEl++(possibleRays nds ray pos newAcc )
--     where
--         newAcc = acc ++ newEl
--         newEl = [(getPos n, solveEq ray pos n)]




-- minRay :: [(Position, Maybe Float)] ->  (Position, Maybe Float) -> Maybe Position
-- minRay [x] ([], _)
--     | snd x == Nothing = Nothing
--     | otherwise = Just (fst x)
-- minRay (x:xs) ([], minV)
--     | snd x == Nothing = minRay xs ([], minV )
--     | otherwise = minRay xs (fst x, (fromJust. snd) x )
-- minRay [j] (pos, minVal)
--     | snd j == Nothing = Just pos
--     | otherwise = if ((fromJust. snd) j) < minVal then (Just (fst j)) else Just pos
-- minRay (j:xs) (pos, min)
--     | snd j == Nothing = minRay xs (pos, min)
--     | otherwise = minRay xs (pos, newMin)
--         where
--             valJ = (fromJust . snd ) j
--             newMin = if valJ < min then valJ else min

